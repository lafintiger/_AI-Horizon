"""
PDF Export Utility for AI-Horizon System

This module provides comprehensive PDF export functionality for all types of content
including individual entries, analysis reports, predictive analytics, and summaries.
"""

import os
import json
import logging
from datetime import datetime
from typing import Dict, Any, Optional, List
from io import BytesIO
import tempfile

try:
    from reportlab.lib.pagesizes import letter, A4
    from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
    from reportlab.lib.units import inch
    from reportlab.lib.colors import HexColor, black, blue, darkblue
    from reportlab.platypus import SimpleDocTemplate, Paragraph, Spacer, Table, TableStyle, PageBreak
    from reportlab.platypus.tableofcontents import TableOfContents
    from reportlab.lib.enums import TA_CENTER, TA_LEFT, TA_RIGHT, TA_JUSTIFY
    REPORTLAB_AVAILABLE = True
except ImportError:
    REPORTLAB_AVAILABLE = False

logger = logging.getLogger(__name__)

# NSF Award Information
NSF_AWARD_NUMBER = "2528858"  # AI Horizon NSF EAGER Project
NSF_DISCLAIMER = """
DISCLAIMER: This document was generated by the AI-Horizon system, a research project 
funded by the National Science Foundation (NSF) under the {award_number} program. 
This system is a work in progress focused on forecasting cybersecurity workforce evolution 
and adaptive skill development. All content should be independently verified for accuracy 
and completeness before making any career, educational, or organizational decisions.

The findings, opinions, and recommendations expressed in this material are those of the 
authors and do not necessarily reflect the views of the National Science Foundation, 
California State University San Bernardino, or other project partners.

This system is under active development and validation. Users should exercise caution 
and verify all information with authoritative sources and subject matter experts.
""".format(award_number=NSF_AWARD_NUMBER)

class PDFExporter:
    """
    Comprehensive PDF export utility for AI-Horizon system using ReportLab.
    
    Provides standardized PDF generation for all content types with consistent
    formatting, disclaimers, and NSF attribution.
    """
    
    def __init__(self):
        if not REPORTLAB_AVAILABLE:
            raise ImportError("ReportLab is required for PDF export functionality")
        
        # Get styles
        self.styles = getSampleStyleSheet()
        
        # Create custom styles
        self.styles.add(ParagraphStyle(
            name='CustomTitle',
            parent=self.styles['Title'],
            fontSize=24,
            spaceAfter=30,
            textColor=HexColor('#2c3e50'),
            alignment=TA_CENTER
        ))
        
        self.styles.add(ParagraphStyle(
            name='CustomHeading1',
            parent=self.styles['Heading1'],
            fontSize=18,
            spaceAfter=12,
            textColor=HexColor('#34495e'),
            leftIndent=0
        ))
        
        self.styles.add(ParagraphStyle(
            name='CustomHeading2',
            parent=self.styles['Heading2'],
            fontSize=14,
            spaceAfter=8,
            textColor=HexColor('#7f8c8d'),
            leftIndent=0
        ))
        
        self.styles.add(ParagraphStyle(
            name='CustomBody',
            parent=self.styles['Normal'],
            fontSize=11,
            spaceAfter=6,
            alignment=TA_JUSTIFY,
            leftIndent=0,
            rightIndent=0
        ))
        
        self.styles.add(ParagraphStyle(
            name='Disclaimer',
            parent=self.styles['Normal'],
            fontSize=9,
            textColor=HexColor('#7f8c8d'),
            alignment=TA_LEFT,
            leftIndent=0,
            rightIndent=0,
            spaceBefore=20,
            spaceAfter=10,
            borderWidth=1,
            borderColor=HexColor('#bdc3c7'),
            borderPadding=10
        ))
    
    def _add_header_footer(self, canvas, doc):
        """Add header and footer to each page."""
        canvas.saveState()
        
        # Header
        canvas.setFont('Helvetica-Bold', 12)
        canvas.setFillColor(HexColor('#2c3e50'))
        canvas.drawString(72, letter[1] - 50, "AI-Horizon Cybersecurity Workforce Intelligence")
        
        # Footer
        canvas.setFont('Helvetica', 9)
        canvas.setFillColor(HexColor('#7f8c8d'))
        footer_text = f"Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')} | NSF Award: {NSF_AWARD_NUMBER}"
        canvas.drawString(72, 50, footer_text)
        
        # Page number
        canvas.drawRightString(letter[0] - 72, 50, f"Page {doc.page}")
        
        canvas.restoreState()
    
    def _create_base_document(self, title: str) -> tuple:
        """Create base document with standard formatting."""
        buffer = BytesIO()
        doc = SimpleDocTemplate(
            buffer,
            pagesize=letter,
            rightMargin=72,
            leftMargin=72,
            topMargin=72,
            bottomMargin=72
        )
        
        story = []
        
        # Title
        story.append(Paragraph(title, self.styles['CustomTitle']))
        story.append(Spacer(1, 20))
        
        return buffer, doc, story
    
    def _add_disclaimer(self, story: List):
        """Add disclaimer and NSF attribution to the document."""
        story.append(PageBreak())
        story.append(Paragraph("IMPORTANT DISCLAIMER", self.styles['CustomHeading1']))
        story.append(Spacer(1, 12))
        story.append(Paragraph(NSF_DISCLAIMER.strip(), self.styles['Disclaimer']))
    
    def export_entry(self, artifact: Dict[str, Any], metadata: Dict[str, Any] = None) -> bytes:
        """Export a single entry as PDF."""
        title = f"AI-Horizon Entry: {artifact.get('title', 'Untitled')}"
        buffer, doc, story = self._create_base_document(title)
        
        # Entry metadata
        story.append(Paragraph("Entry Information", self.styles['CustomHeading1']))
        
        # Create metadata table
        metadata_data = [
            ['Field', 'Value'],
            ['Title', artifact.get('title', 'N/A')],
            ['Source', artifact.get('source', 'N/A')],
            ['Type', artifact.get('type', 'N/A')],
            ['Collected', artifact.get('collected_at', 'N/A')],
        ]
        
        if metadata:
            if metadata.get('ai_impact_category'):
                metadata_data.append(['AI Impact Category', metadata['ai_impact_category']])
            if metadata.get('confidence_score'):
                metadata_data.append(['Confidence Score', f"{metadata['confidence_score']:.2f}"])
        
        metadata_table = Table(metadata_data, colWidths=[2*inch, 4*inch])
        metadata_table.setStyle(TableStyle([
            ('BACKGROUND', (0, 0), (-1, 0), HexColor('#34495e')),
            ('TEXTCOLOR', (0, 0), (-1, 0), HexColor('#ffffff')),
            ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
            ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
            ('FONTSIZE', (0, 0), (-1, 0), 12),
            ('BOTTOMPADDING', (0, 0), (-1, 0), 12),
            ('BACKGROUND', (0, 1), (-1, -1), HexColor('#ecf0f1')),
            ('GRID', (0, 0), (-1, -1), 1, HexColor('#bdc3c7'))
        ]))
        
        story.append(metadata_table)
        story.append(Spacer(1, 20))
        
        # Content
        story.append(Paragraph("Content", self.styles['CustomHeading1']))
        content = artifact.get('content', 'No content available')
        
        # Split content into paragraphs and add them
        paragraphs = content.split('\n\n')
        for paragraph in paragraphs:
            if paragraph.strip():
                story.append(Paragraph(paragraph.strip(), self.styles['CustomBody']))
                story.append(Spacer(1, 6))
        
        # URL if available
        if artifact.get('url') and not artifact['url'].startswith('file://'):
            story.append(Spacer(1, 20))
            story.append(Paragraph("Original Source", self.styles['CustomHeading2']))
            story.append(Paragraph(f"<link href='{artifact['url']}'>{artifact['url']}</link>", self.styles['CustomBody']))
        
        # Add disclaimer
        self._add_disclaimer(story)
        
        # Build PDF
        doc.build(story, onFirstPage=self._add_header_footer, onLaterPages=self._add_header_footer)
        buffer.seek(0)
        return buffer.getvalue()
    
    def export_analysis(self, report_data: Dict[str, Any], analysis_type: str) -> bytes:
        """Export analysis results as PDF."""
        title = f"AI-Horizon {analysis_type.title()} Analysis Report"
        buffer, doc, story = self._create_base_document(title)
        
        # Analysis overview
        story.append(Paragraph("Analysis Overview", self.styles['CustomHeading1']))
        story.append(Paragraph(f"Analysis Type: {analysis_type.title()}", self.styles['CustomBody']))
        story.append(Paragraph(f"Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}", self.styles['CustomBody']))
        
        if 'generated_at' in report_data:
            story.append(Paragraph(f"Report Date: {report_data['generated_at']}", self.styles['CustomBody']))
        
        story.append(Spacer(1, 20))
        
        # If we have markdown content, parse it
        if 'content' in report_data:
            content = report_data['content']
            lines = content.strip().split('\n')
            
            for line in lines:
                line = line.strip()
                if not line:
                    story.append(Spacer(1, 6))
                    continue
                
                if line.startswith('# '):
                    story.append(Paragraph(line[2:], self.styles['CustomHeading1']))
                    story.append(Spacer(1, 12))
                elif line.startswith('## '):
                    story.append(Paragraph(line[3:], self.styles['CustomHeading2']))
                    story.append(Spacer(1, 8))
                elif line.startswith('### '):
                    story.append(Paragraph(line[4:], self.styles['CustomHeading2']))
                    story.append(Spacer(1, 6))
                elif line.startswith('- '):
                    story.append(Paragraph(f"• {line[2:]}", self.styles['CustomBody']))
                elif line.startswith('* '):
                    story.append(Paragraph(f"• {line[2:]}", self.styles['CustomBody']))
                elif line.startswith(('1. ', '2. ', '3. ', '4. ', '5. ')):
                    story.append(Paragraph(line, self.styles['CustomBody']))
                elif line.startswith('|') and '|' in line[1:]:
                    # Skip table formatting for now - could be enhanced later
                    continue
                else:
                    story.append(Paragraph(line, self.styles['CustomBody']))
                    story.append(Spacer(1, 6))
        else:
            # Fallback to old format for compatibility
            # Key findings
            if 'summary' in report_data:
                story.append(Paragraph("Executive Summary", self.styles['CustomHeading1']))
                story.append(Paragraph(str(report_data['summary']), self.styles['CustomBody']))
                story.append(Spacer(1, 20))
            
            # Detailed results
            story.append(Paragraph("Detailed Results", self.styles['CustomHeading1']))
            
            # Convert report data to readable format
            for key, value in report_data.items():
                if key in ['summary', 'content', 'title', 'file_path', 'generated_at']:
                    continue
                
                story.append(Paragraph(key.replace('_', ' ').title(), self.styles['CustomHeading2']))
                
                if isinstance(value, dict):
                    for sub_key, sub_value in value.items():
                        story.append(Paragraph(f"<b>{sub_key.replace('_', ' ').title()}:</b> {sub_value}", self.styles['CustomBody']))
                elif isinstance(value, list):
                    for item in value:
                        story.append(Paragraph(f"• {item}", self.styles['CustomBody']))
                else:
                    story.append(Paragraph(str(value), self.styles['CustomBody']))
                
                story.append(Spacer(1, 12))
        
        # Add disclaimer
        self._add_disclaimer(story)
        
        # Build PDF
        doc.build(story, onFirstPage=self._add_header_footer, onLaterPages=self._add_header_footer)
        buffer.seek(0)
        return buffer.getvalue()
    
    def export_prediction(self, prediction_data: Dict[str, Any], prediction_type: str, timeframe: str) -> bytes:
        """Export predictive analytics as PDF."""
        title = f"AI-Horizon {prediction_type.title()} Predictions ({timeframe})"
        buffer, doc, story = self._create_base_document(title)
        
        # Prediction overview
        story.append(Paragraph("Prediction Overview", self.styles['CustomHeading1']))
        story.append(Paragraph(f"Prediction Type: {prediction_type.replace('_', ' ').title()}", self.styles['CustomBody']))
        story.append(Paragraph(f"Timeframe: {timeframe}", self.styles['CustomBody']))
        story.append(Paragraph(f"Confidence Level: {prediction_data.get('confidence', 'Unknown')}", self.styles['CustomBody']))
        story.append(Paragraph(f"Data Sources: {prediction_data.get('data_sources', 'Unknown')}", self.styles['CustomBody']))
        story.append(Spacer(1, 20))
        
        # Predictions
        if 'predictions' in prediction_data:
            story.append(Paragraph("Key Predictions", self.styles['CustomHeading1']))
            for prediction in prediction_data['predictions']:
                story.append(Paragraph(f"• {prediction}", self.styles['CustomBody']))
            story.append(Spacer(1, 20))
        
        # Methodology
        story.append(Paragraph("Methodology", self.styles['CustomHeading1']))
        methodology_text = f"""
        This prediction analysis was generated using the AI-Horizon predictive analytics engine, 
        which employs machine learning algorithms and statistical modeling to forecast cybersecurity 
        workforce trends. The analysis is based on {prediction_data.get('data_sources', 'multiple data sources')} 
        and uses model version {prediction_data.get('model_version', 'latest')}.
        
        Predictions are generated using time series analysis, pattern recognition, and expert knowledge 
        synthesis. The timeframe analyzed is {timeframe}, with confidence levels calculated based on 
        data quality and historical accuracy.
        """
        story.append(Paragraph(methodology_text.strip(), self.styles['CustomBody']))
        
        # Add disclaimer
        self._add_disclaimer(story)
        
        # Build PDF
        doc.build(story, onFirstPage=self._add_header_footer, onLaterPages=self._add_header_footer)
        buffer.seek(0)
        return buffer.getvalue()
    
    def export_summary(self, summary_data: Dict[str, Any], category: str) -> bytes:
        """Export category summary as PDF."""
        title = f"AI-Horizon {category.replace('_', ' ').title()} Category Summary"
        buffer, doc, story = self._create_base_document(title)
        
        # Category overview
        story.append(Paragraph("Category Overview", self.styles['CustomHeading1']))
        story.append(Paragraph(f"Category: {category.replace('_', ' ').title()}", self.styles['CustomBody']))
        
        if 'statistics' in summary_data:
            stats = summary_data['statistics']
            story.append(Paragraph(f"Total Articles: {stats.get('total_articles', 'Unknown')}", self.styles['CustomBody']))
            story.append(Paragraph(f"Average Confidence: {stats.get('average_confidence', 'Unknown'):.2f}" if isinstance(stats.get('average_confidence'), (int, float)) else "Average Confidence: Unknown", self.styles['CustomBody']))
        
        story.append(Spacer(1, 20))
        
        # Narrative
        if 'narrative' in summary_data:
            story.append(Paragraph("Analysis Narrative", self.styles['CustomHeading1']))
            story.append(Paragraph(summary_data['narrative'].strip(), self.styles['CustomBody']))
            story.append(Spacer(1, 20))
        
        # Top articles
        if 'top_articles' in summary_data and summary_data['top_articles']:
            story.append(Paragraph("Representative Articles", self.styles['CustomHeading1']))
            
            for i, article in enumerate(summary_data['top_articles'][:5], 1):
                story.append(Paragraph(f"{i}. {article.get('title', 'Untitled')}", self.styles['CustomHeading2']))
                story.append(Paragraph(f"Source: {article.get('source', 'Unknown')}", self.styles['CustomBody']))
                if article.get('url') and not article['url'].startswith('file://'):
                    story.append(Paragraph(f"URL: {article['url']}", self.styles['CustomBody']))
                story.append(Spacer(1, 12))
        
        # Add disclaimer
        self._add_disclaimer(story)
        
        # Build PDF
        doc.build(story, onFirstPage=self._add_header_footer, onLaterPages=self._add_header_footer)
        buffer.seek(0)
        return buffer.getvalue()
    
    def export_intelligence(self, report_content: str, report_title: str) -> bytes:
        """Export intelligence report as PDF."""
        buffer, doc, story = self._create_base_document(report_title)
        
        # Parse markdown-like content and convert to PDF
        lines = report_content.strip().split('\n')
        
        for line in lines:
            line = line.strip()
            if not line:
                story.append(Spacer(1, 6))
                continue
            
            if line.startswith('# '):
                story.append(Paragraph(line[2:], self.styles['CustomHeading1']))
                story.append(Spacer(1, 12))
            elif line.startswith('## '):
                story.append(Paragraph(line[3:], self.styles['CustomHeading2']))
                story.append(Spacer(1, 8))
            elif line.startswith('### '):
                story.append(Paragraph(line[4:], self.styles['CustomHeading2']))
                story.append(Spacer(1, 6))
            elif line.startswith('- '):
                story.append(Paragraph(f"• {line[2:]}", self.styles['CustomBody']))
            elif line.startswith('* '):
                story.append(Paragraph(f"• {line[2:]}", self.styles['CustomBody']))
            elif line.startswith(('1. ', '2. ', '3. ', '4. ', '5. ')):
                story.append(Paragraph(line, self.styles['CustomBody']))
            else:
                story.append(Paragraph(line, self.styles['CustomBody']))
                story.append(Spacer(1, 6))
        
        # Add disclaimer
        self._add_disclaimer(story)
        
        # Build PDF
        doc.build(story, onFirstPage=self._add_header_footer, onLaterPages=self._add_header_footer)
        buffer.seek(0)
        return buffer.getvalue()


# Factory function
def create_pdf_exporter() -> PDFExporter:
    """Create and return a PDF exporter instance."""
    return PDFExporter()


# Convenience functions for direct use
def export_entry_to_pdf(artifact: Dict[str, Any], metadata: Dict[str, Any] = None) -> bytes:
    """Export entry to PDF bytes."""
    exporter = create_pdf_exporter()
    return exporter.export_entry(artifact, metadata)


def export_analysis_to_pdf(report_data: Dict[str, Any], analysis_type: str) -> bytes:
    """Export analysis to PDF bytes."""
    exporter = create_pdf_exporter()
    return exporter.export_analysis(report_data, analysis_type)


def export_prediction_to_pdf(prediction_data: Dict[str, Any], prediction_type: str, timeframe: str) -> bytes:
    """Export prediction to PDF bytes."""
    exporter = create_pdf_exporter()
    return exporter.export_prediction(prediction_data, prediction_type, timeframe)


def export_summary_to_pdf(summary_data: Dict[str, Any], category: str) -> bytes:
    """Export summary to PDF bytes."""
    exporter = create_pdf_exporter()
    return exporter.export_summary(summary_data, category)


def export_intelligence_to_pdf(report_content: str, report_title: str) -> bytes:
    """Export intelligence report to PDF bytes."""
    exporter = create_pdf_exporter()
    return exporter.export_intelligence(report_content, report_title) 